import { NextRequest, NextResponse } from 'next/server'
import { renderToBuffer } from '@react-pdf/renderer'
import { createElement } from 'react'
import { format, addDays } from 'date-fns'
import { getRosterPeriodFromDate } from '@/lib/roster-utils'
import {
  createCertificationExpiryReportDocument,
  createCertificationExpiryReportData,
  generateCertificationExpiryReportFilename
} from '@/lib/pdf-certification-expiry-report'

/**
 * Generate and download Certification Expiry PDF Report
 */
export async function POST(request: NextRequest) {
  try {
    console.log('üéØ Starting certification expiry PDF report generation...')

    const body = await request.json()
    const { timeframeDays, generatedBy } = body

    // Validation
    if (!timeframeDays || typeof timeframeDays !== 'number') {
      return NextResponse.json(
        { success: false, error: 'Timeframe days is required and must be a number' },
        { status: 400 }
      )
    }

    if (!generatedBy) {
      return NextResponse.json(
        { success: false, error: 'Generated by information is required' },
        { status: 400 }
      )
    }

    console.log(`üìä Generating report for timeframe: ${timeframeDays} days`)

    // Fetch expiring certifications
    console.log(`üìã Fetching expiring certifications for ${timeframeDays} days...`)

    // Use the correct server URL based on environment
    const baseUrl = process.env.VERCEL_URL
      ? `https://${process.env.VERCEL_URL}`
      : process.env.NEXT_PUBLIC_APP_URL ||
        (process.env.NODE_ENV === 'development' ? 'http://localhost:3000' : 'https://air-niugini-pms.vercel.app')

    const response = await fetch(`${baseUrl}/api/expiring-certifications?daysAhead=${timeframeDays}`)
    if (!response.ok) {
      throw new Error(`Failed to fetch expiring certifications: ${response.status} ${response.statusText}`)
    }

    const result = await response.json()
    if (!result.success) {
      throw new Error(result.error || 'Failed to fetch expiring certifications')
    }

    const rawCertifications = result.data || []

    // Add roster period information to each certification
    const certifications = rawCertifications.map((cert: any) => {
      try {
        // Validate expiry date
        const expiryDate = new Date(cert.expiry_date)
        if (isNaN(expiryDate.getTime())) {
          console.warn(`Invalid expiry date for certification: ${cert.expiry_date}`)
          return {
            ...cert,
            expiry_roster_period: 'Unknown',
            expiry_roster_display: 'Invalid Date'
          }
        }

        const rosterPeriod = getRosterPeriodFromDate(expiryDate)

        // Validate dates before formatting
        let rosterDisplay
        try {
          if (rosterPeriod.startDate && rosterPeriod.endDate &&
              !isNaN(rosterPeriod.startDate.getTime()) && !isNaN(rosterPeriod.endDate.getTime())) {
            rosterDisplay = `${rosterPeriod.code} (${format(rosterPeriod.startDate, 'MMM dd')} - ${format(rosterPeriod.endDate, 'MMM dd, yyyy')})`
          } else {
            rosterDisplay = rosterPeriod.code
          }
        } catch (error) {
          console.warn('Date formatting error for roster period:', error)
          rosterDisplay = rosterPeriod.code
        }

        return {
          ...cert,
          expiry_roster_period: rosterPeriod.code,
          expiry_roster_display: rosterDisplay
        }
      } catch (error) {
        console.warn(`Error processing certification with expiry date ${cert.expiry_date}:`, error)
        return {
          ...cert,
          expiry_roster_period: 'Unknown',
          expiry_roster_display: 'Error Processing Date'
        }
      }
    })

    console.log(`‚úÖ Found ${certifications.length} expiring certifications`)

    // Create report data
    const reportData = createCertificationExpiryReportData(
      timeframeDays,
      certifications,
      generatedBy
    )

    // Generate PDF
    console.log('üîÑ Generating PDF document...')
    const pdfBuffer = await renderToBuffer(
      createCertificationExpiryReportDocument(reportData)
    )

    console.log('‚úÖ PDF generated successfully')

    // Generate filename
    const filename = generateCertificationExpiryReportFilename(timeframeDays)

    // Return PDF as downloadable file
    return new NextResponse(new Uint8Array(pdfBuffer), {
      status: 200,
      headers: {
        'Content-Type': 'application/pdf',
        'Content-Disposition': `attachment; filename="${filename}"`,
        'Content-Length': pdfBuffer.length.toString(),
        'Cache-Control': 'no-cache',
      },
    })

  } catch (error) {
    console.error('‚ùå Error generating certification expiry PDF report:', error)

    return NextResponse.json(
      {
        success: false,
        error: error instanceof Error ? error.message : 'Failed to generate PDF report'
      },
      { status: 500 }
    )
  }
}

/**
 * Get available timeframe options for report generation
 */
export async function GET(request: NextRequest) {
  try {
    console.log('üìÖ Fetching available timeframe options...')

    const timeframeOptions = [
      { value: 30, label: 'Next 30 Days', description: 'Immediate attention required' },
      { value: 60, label: 'Next 60 Days', description: 'Training planning window' },
      { value: 90, label: 'Next 90 Days', description: 'Strategic planning window' },
      { value: 120, label: 'Next 120 Days', description: 'Long-term planning' },
      { value: 180, label: 'Next 6 Months', description: 'Annual planning view' }
    ]

    return NextResponse.json({
      success: true,
      data: timeframeOptions
    })

  } catch (error) {
    console.error('‚ùå Error fetching timeframe options:', error)

    return NextResponse.json(
      {
        success: false,
        error: error instanceof Error ? error.message : 'Failed to fetch timeframe options'
      },
      { status: 500 }
    )
  }
}

// Force dynamic rendering for this API route
export const dynamic = 'force-dynamic'