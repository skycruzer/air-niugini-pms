import { NextRequest, NextResponse } from 'next/server';
import { renderToBuffer } from '@react-pdf/renderer';
import { createElement } from 'react';
import { format, addDays } from 'date-fns';
import { getRosterPeriodFromDate } from '@/lib/roster-utils';
import { getExpiringCertifications } from '@/lib/expiring-certifications-service';
import { logger } from '@/lib/logger';
import {
  createCertificationExpiryReportDocument,
  createCertificationExpiryReportData,
  generateCertificationExpiryReportFilename,
} from '@/lib/pdf-certification-expiry-report';

/**
 * Generate and download Certification Expiry PDF Report
 */
export async function POST(request: NextRequest) {
  try {
    logger.debug('ðŸŽ¯ Starting certification expiry PDF report generation...');

    const body = await request.json();
    const { timeframeDays, generatedBy } = body;

    // Validation
    if (!timeframeDays || typeof timeframeDays !== 'number') {
      return NextResponse.json(
        { success: false, error: 'Timeframe days is required and must be a number' },
        { status: 400 }
      );
    }

    if (!generatedBy) {
      return NextResponse.json(
        { success: false, error: 'Generated by information is required' },
        { status: 400 }
      );
    }

    logger.debug(`ðŸ“Š Generating report for timeframe: ${timeframeDays} days`);

    // Fetch expiring certifications using the service function (direct call, no HTTP)
    logger.debug(`ðŸ“‹ Fetching expiring certifications for ${timeframeDays} days...`);

    const serviceData = await getExpiringCertifications(timeframeDays);

    logger.debug(`âœ… Found ${serviceData.length} expiring certifications`);

    // Transform service data to match PDF interface format
    const certifications = serviceData.map((cert: any) => ({
      id: cert.id || 'unknown',
      pilot_id: cert.id || 'unknown',
      check_type_id: cert.id || 'unknown',
      expiry_date:
        cert.expiryDate instanceof Date
          ? cert.expiryDate.toISOString().split('T')[0]
          : String(cert.expiryDate),
      days_until_expiry: cert.status?.daysUntilExpiry || 0,
      pilot_name: cert.pilotName || 'Unknown',
      employee_id: cert.employeeId || 'N/A',
      check_type_name: cert.checkDescription || 'Unknown',
      check_category: cert.category || 'Unknown',
      is_expired: (cert.status?.daysUntilExpiry || 0) < 0,
      expiry_roster_period: cert.expiry_roster_period || 'Unknown',
      expiry_roster_display: cert.expiry_roster_display || 'Unknown',
    }));

    logger.debug(`ðŸ”„ Transformed ${certifications.length} certifications for PDF generation`);

    // Create report data
    const reportData = createCertificationExpiryReportData(
      timeframeDays,
      certifications,
      generatedBy
    );

    // Generate PDF
    logger.debug(' Generating PDF document...');

    let pdfBuffer: Buffer;
    try {
      const pdfDocumentElement = createCertificationExpiryReportDocument(reportData);
      logger.debug('ðŸ“„ PDF document created, rendering to buffer...');

      pdfBuffer = await renderToBuffer(pdfDocumentElement);
      logger.info(' PDF buffer generated successfully, size:', pdfBuffer.length, 'bytes');

      if (pdfBuffer.length === 0) {
        throw new Error('PDF buffer is empty');
      }
    } catch (pdfError: any) {
      logger.error(' PDF generation error:', pdfError);
      throw new Error(`PDF generation failed: ${pdfError?.message || 'Unknown error'}`);
    }

    // Generate filename
    const filename = generateCertificationExpiryReportFilename(timeframeDays);

    // Return PDF as downloadable file
    return new NextResponse(new Uint8Array(pdfBuffer), {
      status: 200,
      headers: {
        'Content-Type': 'application/pdf',
        'Content-Disposition': `attachment; filename="${filename}"`,
        'Content-Length': pdfBuffer.length.toString(),
        'Cache-Control': 'no-cache',
      },
    });
  } catch (error) {
    logger.error(' Error generating certification expiry PDF report:', error);

    return NextResponse.json(
      {
        success: false,
        error: error instanceof Error ? error.message : 'Failed to generate PDF report',
      },
      { status: 500 }
    );
  }
}

/**
 * Get available timeframe options for report generation
 */
export async function GET(request: NextRequest) {
  try {
    logger.debug('ðŸ“… Fetching available timeframe options...');

    const timeframeOptions = [
      { value: 30, label: 'Next 30 Days', description: 'Immediate attention required' },
      { value: 60, label: 'Next 60 Days', description: 'Training planning window' },
      { value: 90, label: 'Next 90 Days', description: 'Strategic planning window' },
      { value: 120, label: 'Next 120 Days', description: 'Long-term planning' },
      { value: 180, label: 'Next 6 Months', description: 'Annual planning view' },
    ];

    return NextResponse.json({
      success: true,
      data: timeframeOptions,
    });
  } catch (error) {
    logger.error(' Error fetching timeframe options:', error);

    return NextResponse.json(
      {
        success: false,
        error: error instanceof Error ? error.message : 'Failed to fetch timeframe options',
      },
      { status: 500 }
    );
  }
}

// Force dynamic rendering for this API route
export const dynamic = 'force-dynamic';
